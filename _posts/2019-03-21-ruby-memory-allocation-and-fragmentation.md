---
title: Ruby内存分配与碎片
categories: programming
tags: Ruby
---

# Ruby内存分配与碎片

## Ruby内存分配

Ruby中的内存分配涉及三层，从高级到低级排序：

1. Ruby解释器，管理Ruby对象
2. 操作系统的内存分配器库
3. 内核

### Ruby级别

Ruby在称为 *Ruby堆页面 (Ruby heap page)* 的内存区域中组织对象。这样的Ruby堆页面被拆分成相等大小的 *插槽 (slot)*，其中一个对象占用一个插槽。无论是字符串，哈希表，数组，类还是其他，它都占用一个插槽。

Ruby堆页面中的插槽可以被占用也可以是空闲的。 当Ruby分配一个新对象时，它首先尝试占用一个空闲槽。如果没有空闲插槽，那么它将分配一个新的Ruby堆页面。

插槽很小，大约 __40个字节__。显然，并非所有Ruby对象都适合这里，不适合插槽的数据存储在Ruby堆页面之外，然后在插槽中放置一个指针指向外部数据。

__Ruby堆页面和任何外部数据都是使用系统的内存分配器分配的。__

### 操作系统（内存分配器）级别

操作系统的内存分配器是一个库，它是 *glibc (C运行时)* 的一部分。它几乎被所有应用程序使用，而不仅仅是Ruby。它有一个简单的API：

* 通过调用 `malloc(size)` 来分配内存，传递需分配的字节数，并返回分配的地址或错误。
* 通过调用 `free(address)` 释放分配的内存。

内存分配器从内核分配的内存区域称为 *堆 (heap)*。请注意，这与Ruby堆页面无关，因此为了清楚起见，我将使用术语 *OS堆 (OS heap)*。

内存分配器通过调用内核的API分配内存。内存分配器从内核请求分配的内存块比其自己的调用者请求的大得多，因为调用内核是昂贵的，还因为内核API有一个限制——它只能以 __4 KB__ 为单位分配内存。

内存分配器将OS堆的各个部分分配给其调用者，直到没有更多可用空间为止，内存分配器再从内核分配新的OS堆。这类似于Ruby从Ruby堆页面分配对象的方式。

与大多数时间处理大小相同的插槽的Ruby不同，内存分配器必须处理任何大小的内存分配请求，这便导致了一些问题，后续将提到。

### 内核级别

内核只能以4 KB为单位分配内存。一个这样的4 KB单元称为 *页面 (page)* 。不要与Ruby堆页面混淆，因此，为了清楚起见，我将使用术语 *OS页面 (OS page)*。

通过内核分配内存也会对性能产生重大影响，因此内存分配器会尝试最小化内核调用的数量。

因此，内存分配存在于多个级别，每个级别分配的内存比实际需要的都多——Ruby堆页面可以有空闲插槽、操作系统堆也可以存在空缺部分，所以内存占用从不同的级别有不同的结论，当使用 `top` 或 `ps` 等工具来观测进程的内存使用情况时，它们是从内核的角度告诉你内存的使用情况。

## 哪来的碎片

由于内存分配存在于多个级别，故不同级别都会产生碎片。

### Ruby级别

Ruby有垃圾回收机制，回收对象的垃圾意味着将Ruby堆页面槽标记为空闲，允许重用该槽。如果整个Ruby堆页面最终只包含空闲槽，则整个Ruby堆页面可以释放回内存分配器（并可能返回到内核）。

但是，如果不是所有的插槽都是空闲的，假设你有很多Ruby堆页面，垃圾回收会释放不同位置的对象，这样即使你最终会有很多空闲插槽，但还有很多Ruby堆页面并不完全由空闲插槽组成。即使Ruby有空闲插槽来分配对象，就内存分配器和内核而言，它们仍然被分配了内存！

### 操作系统（内存分配器）级别

内存分配器有一个类似但却完全不同的问题。内存分配器不必一次释放整个OS堆。从理论上讲，它可以释放任何单独的OS页面，但由于内存分配器必须处理任何大小的分配，所以一个OS页面可能包含多个（进程的）分配，故直到所有的分配被释放之前该OS页面都不能被释放。

因此，如果运气不好，那么最终可能会遇到OS堆中有大量可用空间的情况，但并没有多少完全空闲的OS页面。最坏的情况是虽然在不同的OS页面中存在大量空闲的位置，但都不足以容纳新的请求，此时内存分配器会去请求一个新的OS堆。

## 降低内存使用率

现有两种方法降低内存使用率，一是将内存分配器换为 `jemalloc`，再就是设置神奇的环境变量 `MALLOC_ARENA_MAX=2`

`MALLOC_ARENA_MAX=2` 能降低内存使用率与多线程有关。由于一次只能有一个线程在OS堆上运行，因此在多线程方案中，这会导致竞争，从而导致性能下降。

内存分配器对此方案进行了优化，它尝试创建多个OS堆，并尝试对应分配给不同线程。大多数情况下，线程只需要使用该堆，从而避免与其他线程争用。

实际上默认情况下，以这种方式分配的OS堆的最大数量等于虚拟CPU数量的8倍。所以在超线程双核CPU下便会产生 `2 * 2 * 8 = 32` 个OS堆！而更多的OS堆意味着更多的碎片，故通过设置 `MALLOC_ARENA_MAX` 变量能在减少线程竞争的情况下同时限制最大的OS堆产生数，也就能有效的减少碎片。

Ref: [What causes Ruby memory bloat?](https://www.joyfulbikeshedding.com/blog/2019-03-14-what-causes-ruby-memory-bloat.html)


